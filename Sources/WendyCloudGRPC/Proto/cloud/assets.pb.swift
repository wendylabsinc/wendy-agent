// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: cloud/assets.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Wendycloud_V1_Asset: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int32 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var organizationID: Int32 {
    get {return _storage._organizationID}
    set {_uniqueStorage()._organizationID = newValue}
  }

  public var parentAssetID: Int32 {
    get {return _storage._parentAssetID ?? 0}
    set {_uniqueStorage()._parentAssetID = newValue}
  }
  /// Returns true if `parentAssetID` has been explicitly set.
  public var hasParentAssetID: Bool {return _storage._parentAssetID != nil}
  /// Clears the value of `parentAssetID`. Subsequent reads from it will return its default value.
  public mutating func clearParentAssetID() {_uniqueStorage()._parentAssetID = nil}

  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  public var details: String {
    get {return _storage._details}
    set {_uniqueStorage()._details = newValue}
  }

  public var assetType: String {
    get {return _storage._assetType}
    set {_uniqueStorage()._assetType = newValue}
  }

  /// Blob storage fields
  public var blobStorageURL: String {
    get {return _storage._blobStorageURL ?? String()}
    set {_uniqueStorage()._blobStorageURL = newValue}
  }
  /// Returns true if `blobStorageURL` has been explicitly set.
  public var hasBlobStorageURL: Bool {return _storage._blobStorageURL != nil}
  /// Clears the value of `blobStorageURL`. Subsequent reads from it will return its default value.
  public mutating func clearBlobStorageURL() {_uniqueStorage()._blobStorageURL = nil}

  public var blobContentType: String {
    get {return _storage._blobContentType ?? String()}
    set {_uniqueStorage()._blobContentType = newValue}
  }
  /// Returns true if `blobContentType` has been explicitly set.
  public var hasBlobContentType: Bool {return _storage._blobContentType != nil}
  /// Clears the value of `blobContentType`. Subsequent reads from it will return its default value.
  public mutating func clearBlobContentType() {_uniqueStorage()._blobContentType = nil}

  public var blobSizeBytes: Int64 {
    get {return _storage._blobSizeBytes ?? 0}
    set {_uniqueStorage()._blobSizeBytes = newValue}
  }
  /// Returns true if `blobSizeBytes` has been explicitly set.
  public var hasBlobSizeBytes: Bool {return _storage._blobSizeBytes != nil}
  /// Clears the value of `blobSizeBytes`. Subsequent reads from it will return its default value.
  public mutating func clearBlobSizeBytes() {_uniqueStorage()._blobSizeBytes = nil}

  public var blobMetadata: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _storage._blobMetadata ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_uniqueStorage()._blobMetadata = newValue}
  }
  /// Returns true if `blobMetadata` has been explicitly set.
  public var hasBlobMetadata: Bool {return _storage._blobMetadata != nil}
  /// Clears the value of `blobMetadata`. Subsequent reads from it will return its default value.
  public mutating func clearBlobMetadata() {_uniqueStorage()._blobMetadata = nil}

  /// Compute device fields
  public var isComputeDevice: Bool {
    get {return _storage._isComputeDevice}
    set {_uniqueStorage()._isComputeDevice = newValue}
  }

  public var deviceType: String {
    get {return _storage._deviceType ?? String()}
    set {_uniqueStorage()._deviceType = newValue}
  }
  /// Returns true if `deviceType` has been explicitly set.
  public var hasDeviceType: Bool {return _storage._deviceType != nil}
  /// Clears the value of `deviceType`. Subsequent reads from it will return its default value.
  public mutating func clearDeviceType() {_uniqueStorage()._deviceType = nil}

  public var architecture: String {
    get {return _storage._architecture ?? String()}
    set {_uniqueStorage()._architecture = newValue}
  }
  /// Returns true if `architecture` has been explicitly set.
  public var hasArchitecture: Bool {return _storage._architecture != nil}
  /// Clears the value of `architecture`. Subsequent reads from it will return its default value.
  public mutating func clearArchitecture() {_uniqueStorage()._architecture = nil}

  public var cpuCores: Int32 {
    get {return _storage._cpuCores ?? 0}
    set {_uniqueStorage()._cpuCores = newValue}
  }
  /// Returns true if `cpuCores` has been explicitly set.
  public var hasCpuCores: Bool {return _storage._cpuCores != nil}
  /// Clears the value of `cpuCores`. Subsequent reads from it will return its default value.
  public mutating func clearCpuCores() {_uniqueStorage()._cpuCores = nil}

  public var ramMb: Int32 {
    get {return _storage._ramMb ?? 0}
    set {_uniqueStorage()._ramMb = newValue}
  }
  /// Returns true if `ramMb` has been explicitly set.
  public var hasRamMb: Bool {return _storage._ramMb != nil}
  /// Clears the value of `ramMb`. Subsequent reads from it will return its default value.
  public mutating func clearRamMb() {_uniqueStorage()._ramMb = nil}

  public var storageGb: Int32 {
    get {return _storage._storageGb ?? 0}
    set {_uniqueStorage()._storageGb = newValue}
  }
  /// Returns true if `storageGb` has been explicitly set.
  public var hasStorageGb: Bool {return _storage._storageGb != nil}
  /// Clears the value of `storageGb`. Subsequent reads from it will return its default value.
  public mutating func clearStorageGb() {_uniqueStorage()._storageGb = nil}

  public var osType: String {
    get {return _storage._osType ?? String()}
    set {_uniqueStorage()._osType = newValue}
  }
  /// Returns true if `osType` has been explicitly set.
  public var hasOsType: Bool {return _storage._osType != nil}
  /// Clears the value of `osType`. Subsequent reads from it will return its default value.
  public mutating func clearOsType() {_uniqueStorage()._osType = nil}

  public var osVersion: String {
    get {return _storage._osVersion ?? String()}
    set {_uniqueStorage()._osVersion = newValue}
  }
  /// Returns true if `osVersion` has been explicitly set.
  public var hasOsVersion: Bool {return _storage._osVersion != nil}
  /// Clears the value of `osVersion`. Subsequent reads from it will return its default value.
  public mutating func clearOsVersion() {_uniqueStorage()._osVersion = nil}

  public var ipAddress: String {
    get {return _storage._ipAddress ?? String()}
    set {_uniqueStorage()._ipAddress = newValue}
  }
  /// Returns true if `ipAddress` has been explicitly set.
  public var hasIpAddress: Bool {return _storage._ipAddress != nil}
  /// Clears the value of `ipAddress`. Subsequent reads from it will return its default value.
  public mutating func clearIpAddress() {_uniqueStorage()._ipAddress = nil}

  public var macAddress: String {
    get {return _storage._macAddress ?? String()}
    set {_uniqueStorage()._macAddress = newValue}
  }
  /// Returns true if `macAddress` has been explicitly set.
  public var hasMacAddress: Bool {return _storage._macAddress != nil}
  /// Clears the value of `macAddress`. Subsequent reads from it will return its default value.
  public mutating func clearMacAddress() {_uniqueStorage()._macAddress = nil}

  /// Tags for filtering and organization
  public var tags: [String] {
    get {return _storage._tags}
    set {_uniqueStorage()._tags = newValue}
  }

  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return _storage._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {_uniqueStorage()._createdAt = nil}

  public var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  public var hasUpdatedAt: Bool {return _storage._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  public mutating func clearUpdatedAt() {_uniqueStorage()._updatedAt = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Wendycloud_V1_CreateAssetRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var organizationID: Int32 {
    get {return _storage._organizationID}
    set {_uniqueStorage()._organizationID = newValue}
  }

  public var parentAssetID: Int32 {
    get {return _storage._parentAssetID ?? 0}
    set {_uniqueStorage()._parentAssetID = newValue}
  }
  /// Returns true if `parentAssetID` has been explicitly set.
  public var hasParentAssetID: Bool {return _storage._parentAssetID != nil}
  /// Clears the value of `parentAssetID`. Subsequent reads from it will return its default value.
  public mutating func clearParentAssetID() {_uniqueStorage()._parentAssetID = nil}

  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  public var details: String {
    get {return _storage._details}
    set {_uniqueStorage()._details = newValue}
  }

  public var assetType: String {
    get {return _storage._assetType}
    set {_uniqueStorage()._assetType = newValue}
  }

  public var blobStorageURL: String {
    get {return _storage._blobStorageURL ?? String()}
    set {_uniqueStorage()._blobStorageURL = newValue}
  }
  /// Returns true if `blobStorageURL` has been explicitly set.
  public var hasBlobStorageURL: Bool {return _storage._blobStorageURL != nil}
  /// Clears the value of `blobStorageURL`. Subsequent reads from it will return its default value.
  public mutating func clearBlobStorageURL() {_uniqueStorage()._blobStorageURL = nil}

  public var blobContentType: String {
    get {return _storage._blobContentType ?? String()}
    set {_uniqueStorage()._blobContentType = newValue}
  }
  /// Returns true if `blobContentType` has been explicitly set.
  public var hasBlobContentType: Bool {return _storage._blobContentType != nil}
  /// Clears the value of `blobContentType`. Subsequent reads from it will return its default value.
  public mutating func clearBlobContentType() {_uniqueStorage()._blobContentType = nil}

  public var blobSizeBytes: Int64 {
    get {return _storage._blobSizeBytes ?? 0}
    set {_uniqueStorage()._blobSizeBytes = newValue}
  }
  /// Returns true if `blobSizeBytes` has been explicitly set.
  public var hasBlobSizeBytes: Bool {return _storage._blobSizeBytes != nil}
  /// Clears the value of `blobSizeBytes`. Subsequent reads from it will return its default value.
  public mutating func clearBlobSizeBytes() {_uniqueStorage()._blobSizeBytes = nil}

  public var blobMetadata: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _storage._blobMetadata ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_uniqueStorage()._blobMetadata = newValue}
  }
  /// Returns true if `blobMetadata` has been explicitly set.
  public var hasBlobMetadata: Bool {return _storage._blobMetadata != nil}
  /// Clears the value of `blobMetadata`. Subsequent reads from it will return its default value.
  public mutating func clearBlobMetadata() {_uniqueStorage()._blobMetadata = nil}

  public var isComputeDevice: Bool {
    get {return _storage._isComputeDevice}
    set {_uniqueStorage()._isComputeDevice = newValue}
  }

  public var deviceType: String {
    get {return _storage._deviceType ?? String()}
    set {_uniqueStorage()._deviceType = newValue}
  }
  /// Returns true if `deviceType` has been explicitly set.
  public var hasDeviceType: Bool {return _storage._deviceType != nil}
  /// Clears the value of `deviceType`. Subsequent reads from it will return its default value.
  public mutating func clearDeviceType() {_uniqueStorage()._deviceType = nil}

  public var architecture: String {
    get {return _storage._architecture ?? String()}
    set {_uniqueStorage()._architecture = newValue}
  }
  /// Returns true if `architecture` has been explicitly set.
  public var hasArchitecture: Bool {return _storage._architecture != nil}
  /// Clears the value of `architecture`. Subsequent reads from it will return its default value.
  public mutating func clearArchitecture() {_uniqueStorage()._architecture = nil}

  public var cpuCores: Int32 {
    get {return _storage._cpuCores ?? 0}
    set {_uniqueStorage()._cpuCores = newValue}
  }
  /// Returns true if `cpuCores` has been explicitly set.
  public var hasCpuCores: Bool {return _storage._cpuCores != nil}
  /// Clears the value of `cpuCores`. Subsequent reads from it will return its default value.
  public mutating func clearCpuCores() {_uniqueStorage()._cpuCores = nil}

  public var ramMb: Int32 {
    get {return _storage._ramMb ?? 0}
    set {_uniqueStorage()._ramMb = newValue}
  }
  /// Returns true if `ramMb` has been explicitly set.
  public var hasRamMb: Bool {return _storage._ramMb != nil}
  /// Clears the value of `ramMb`. Subsequent reads from it will return its default value.
  public mutating func clearRamMb() {_uniqueStorage()._ramMb = nil}

  public var storageGb: Int32 {
    get {return _storage._storageGb ?? 0}
    set {_uniqueStorage()._storageGb = newValue}
  }
  /// Returns true if `storageGb` has been explicitly set.
  public var hasStorageGb: Bool {return _storage._storageGb != nil}
  /// Clears the value of `storageGb`. Subsequent reads from it will return its default value.
  public mutating func clearStorageGb() {_uniqueStorage()._storageGb = nil}

  public var osType: String {
    get {return _storage._osType ?? String()}
    set {_uniqueStorage()._osType = newValue}
  }
  /// Returns true if `osType` has been explicitly set.
  public var hasOsType: Bool {return _storage._osType != nil}
  /// Clears the value of `osType`. Subsequent reads from it will return its default value.
  public mutating func clearOsType() {_uniqueStorage()._osType = nil}

  public var osVersion: String {
    get {return _storage._osVersion ?? String()}
    set {_uniqueStorage()._osVersion = newValue}
  }
  /// Returns true if `osVersion` has been explicitly set.
  public var hasOsVersion: Bool {return _storage._osVersion != nil}
  /// Clears the value of `osVersion`. Subsequent reads from it will return its default value.
  public mutating func clearOsVersion() {_uniqueStorage()._osVersion = nil}

  public var ipAddress: String {
    get {return _storage._ipAddress ?? String()}
    set {_uniqueStorage()._ipAddress = newValue}
  }
  /// Returns true if `ipAddress` has been explicitly set.
  public var hasIpAddress: Bool {return _storage._ipAddress != nil}
  /// Clears the value of `ipAddress`. Subsequent reads from it will return its default value.
  public mutating func clearIpAddress() {_uniqueStorage()._ipAddress = nil}

  public var macAddress: String {
    get {return _storage._macAddress ?? String()}
    set {_uniqueStorage()._macAddress = newValue}
  }
  /// Returns true if `macAddress` has been explicitly set.
  public var hasMacAddress: Bool {return _storage._macAddress != nil}
  /// Clears the value of `macAddress`. Subsequent reads from it will return its default value.
  public mutating func clearMacAddress() {_uniqueStorage()._macAddress = nil}

  public var tags: [String] {
    get {return _storage._tags}
    set {_uniqueStorage()._tags = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Wendycloud_V1_GetAssetRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Wendycloud_V1_UpdateAssetRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int32 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var name: String {
    get {return _storage._name ?? String()}
    set {_uniqueStorage()._name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  public var hasName: Bool {return _storage._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  public mutating func clearName() {_uniqueStorage()._name = nil}

  public var details: String {
    get {return _storage._details ?? String()}
    set {_uniqueStorage()._details = newValue}
  }
  /// Returns true if `details` has been explicitly set.
  public var hasDetails: Bool {return _storage._details != nil}
  /// Clears the value of `details`. Subsequent reads from it will return its default value.
  public mutating func clearDetails() {_uniqueStorage()._details = nil}

  public var blobStorageURL: String {
    get {return _storage._blobStorageURL ?? String()}
    set {_uniqueStorage()._blobStorageURL = newValue}
  }
  /// Returns true if `blobStorageURL` has been explicitly set.
  public var hasBlobStorageURL: Bool {return _storage._blobStorageURL != nil}
  /// Clears the value of `blobStorageURL`. Subsequent reads from it will return its default value.
  public mutating func clearBlobStorageURL() {_uniqueStorage()._blobStorageURL = nil}

  public var blobContentType: String {
    get {return _storage._blobContentType ?? String()}
    set {_uniqueStorage()._blobContentType = newValue}
  }
  /// Returns true if `blobContentType` has been explicitly set.
  public var hasBlobContentType: Bool {return _storage._blobContentType != nil}
  /// Clears the value of `blobContentType`. Subsequent reads from it will return its default value.
  public mutating func clearBlobContentType() {_uniqueStorage()._blobContentType = nil}

  public var blobSizeBytes: Int64 {
    get {return _storage._blobSizeBytes ?? 0}
    set {_uniqueStorage()._blobSizeBytes = newValue}
  }
  /// Returns true if `blobSizeBytes` has been explicitly set.
  public var hasBlobSizeBytes: Bool {return _storage._blobSizeBytes != nil}
  /// Clears the value of `blobSizeBytes`. Subsequent reads from it will return its default value.
  public mutating func clearBlobSizeBytes() {_uniqueStorage()._blobSizeBytes = nil}

  public var blobMetadata: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _storage._blobMetadata ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_uniqueStorage()._blobMetadata = newValue}
  }
  /// Returns true if `blobMetadata` has been explicitly set.
  public var hasBlobMetadata: Bool {return _storage._blobMetadata != nil}
  /// Clears the value of `blobMetadata`. Subsequent reads from it will return its default value.
  public mutating func clearBlobMetadata() {_uniqueStorage()._blobMetadata = nil}

  public var deviceType: String {
    get {return _storage._deviceType ?? String()}
    set {_uniqueStorage()._deviceType = newValue}
  }
  /// Returns true if `deviceType` has been explicitly set.
  public var hasDeviceType: Bool {return _storage._deviceType != nil}
  /// Clears the value of `deviceType`. Subsequent reads from it will return its default value.
  public mutating func clearDeviceType() {_uniqueStorage()._deviceType = nil}

  public var architecture: String {
    get {return _storage._architecture ?? String()}
    set {_uniqueStorage()._architecture = newValue}
  }
  /// Returns true if `architecture` has been explicitly set.
  public var hasArchitecture: Bool {return _storage._architecture != nil}
  /// Clears the value of `architecture`. Subsequent reads from it will return its default value.
  public mutating func clearArchitecture() {_uniqueStorage()._architecture = nil}

  public var cpuCores: Int32 {
    get {return _storage._cpuCores ?? 0}
    set {_uniqueStorage()._cpuCores = newValue}
  }
  /// Returns true if `cpuCores` has been explicitly set.
  public var hasCpuCores: Bool {return _storage._cpuCores != nil}
  /// Clears the value of `cpuCores`. Subsequent reads from it will return its default value.
  public mutating func clearCpuCores() {_uniqueStorage()._cpuCores = nil}

  public var ramMb: Int32 {
    get {return _storage._ramMb ?? 0}
    set {_uniqueStorage()._ramMb = newValue}
  }
  /// Returns true if `ramMb` has been explicitly set.
  public var hasRamMb: Bool {return _storage._ramMb != nil}
  /// Clears the value of `ramMb`. Subsequent reads from it will return its default value.
  public mutating func clearRamMb() {_uniqueStorage()._ramMb = nil}

  public var storageGb: Int32 {
    get {return _storage._storageGb ?? 0}
    set {_uniqueStorage()._storageGb = newValue}
  }
  /// Returns true if `storageGb` has been explicitly set.
  public var hasStorageGb: Bool {return _storage._storageGb != nil}
  /// Clears the value of `storageGb`. Subsequent reads from it will return its default value.
  public mutating func clearStorageGb() {_uniqueStorage()._storageGb = nil}

  public var osType: String {
    get {return _storage._osType ?? String()}
    set {_uniqueStorage()._osType = newValue}
  }
  /// Returns true if `osType` has been explicitly set.
  public var hasOsType: Bool {return _storage._osType != nil}
  /// Clears the value of `osType`. Subsequent reads from it will return its default value.
  public mutating func clearOsType() {_uniqueStorage()._osType = nil}

  public var osVersion: String {
    get {return _storage._osVersion ?? String()}
    set {_uniqueStorage()._osVersion = newValue}
  }
  /// Returns true if `osVersion` has been explicitly set.
  public var hasOsVersion: Bool {return _storage._osVersion != nil}
  /// Clears the value of `osVersion`. Subsequent reads from it will return its default value.
  public mutating func clearOsVersion() {_uniqueStorage()._osVersion = nil}

  public var ipAddress: String {
    get {return _storage._ipAddress ?? String()}
    set {_uniqueStorage()._ipAddress = newValue}
  }
  /// Returns true if `ipAddress` has been explicitly set.
  public var hasIpAddress: Bool {return _storage._ipAddress != nil}
  /// Clears the value of `ipAddress`. Subsequent reads from it will return its default value.
  public mutating func clearIpAddress() {_uniqueStorage()._ipAddress = nil}

  public var macAddress: String {
    get {return _storage._macAddress ?? String()}
    set {_uniqueStorage()._macAddress = newValue}
  }
  /// Returns true if `macAddress` has been explicitly set.
  public var hasMacAddress: Bool {return _storage._macAddress != nil}
  /// Clears the value of `macAddress`. Subsequent reads from it will return its default value.
  public mutating func clearMacAddress() {_uniqueStorage()._macAddress = nil}

  public var tags: [String] {
    get {return _storage._tags}
    set {_uniqueStorage()._tags = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Wendycloud_V1_DeleteAssetRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Wendycloud_V1_DeleteAssetResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var success: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Wendycloud_V1_ListAssetsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var organizationID: Int32 = 0

  public var isComputeDevice: Bool {
    get {return _isComputeDevice ?? false}
    set {_isComputeDevice = newValue}
  }
  /// Returns true if `isComputeDevice` has been explicitly set.
  public var hasIsComputeDevice: Bool {return self._isComputeDevice != nil}
  /// Clears the value of `isComputeDevice`. Subsequent reads from it will return its default value.
  public mutating func clearIsComputeDevice() {self._isComputeDevice = nil}

  public var pageSize: Int32 = 0

  public var pageToken: String = String()

  /// Filter by name, details, asset_type, device_type, or tags
  public var filter: String {
    get {return _filter ?? String()}
    set {_filter = newValue}
  }
  /// Returns true if `filter` has been explicitly set.
  public var hasFilter: Bool {return self._filter != nil}
  /// Clears the value of `filter`. Subsequent reads from it will return its default value.
  public mutating func clearFilter() {self._filter = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _isComputeDevice: Bool? = nil
  fileprivate var _filter: String? = nil
}

public struct Wendycloud_V1_ListAssetsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var assets: [Wendycloud_V1_Asset] = []

  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Wendycloud_V1_ListAssetChildrenRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var parentAssetID: Int32 = 0

  public var pageSize: Int32 = 0

  public var pageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Wendycloud_V1_ListAssetChildrenResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var assets: [Wendycloud_V1_Asset] = []

  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Wendycloud_V1_GetAssetLineageRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var assetID: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Wendycloud_V1_GetAssetLineageResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The root asset (top-most parent)
  public var rootAsset: Wendycloud_V1_Asset {
    get {return _rootAsset ?? Wendycloud_V1_Asset()}
    set {_rootAsset = newValue}
  }
  /// Returns true if `rootAsset` has been explicitly set.
  public var hasRootAsset: Bool {return self._rootAsset != nil}
  /// Clears the value of `rootAsset`. Subsequent reads from it will return its default value.
  public mutating func clearRootAsset() {self._rootAsset = nil}

  /// All assets in the lineage tree (including root and all descendants)
  public var allAssets: [Wendycloud_V1_Asset] = []

  /// The asset ID that was requested (for highlighting)
  public var requestedAssetID: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _rootAsset: Wendycloud_V1_Asset? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "wendycloud.v1"

extension Wendycloud_V1_Asset: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Asset"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{3}organization_id\0\u{3}parent_asset_id\0\u{1}name\0\u{1}details\0\u{3}asset_type\0\u{3}blob_storage_url\0\u{3}blob_content_type\0\u{3}blob_size_bytes\0\u{3}blob_metadata\0\u{3}is_compute_device\0\u{3}device_type\0\u{1}architecture\0\u{3}cpu_cores\0\u{3}ram_mb\0\u{3}storage_gb\0\u{3}os_type\0\u{3}os_version\0\u{3}ip_address\0\u{3}mac_address\0\u{3}created_at\0\u{3}updated_at\0\u{1}tags\0")

  fileprivate class _StorageClass {
    var _id: Int32 = 0
    var _organizationID: Int32 = 0
    var _parentAssetID: Int32? = nil
    var _name: String = String()
    var _details: String = String()
    var _assetType: String = String()
    var _blobStorageURL: String? = nil
    var _blobContentType: String? = nil
    var _blobSizeBytes: Int64? = nil
    var _blobMetadata: SwiftProtobuf.Google_Protobuf_Struct? = nil
    var _isComputeDevice: Bool = false
    var _deviceType: String? = nil
    var _architecture: String? = nil
    var _cpuCores: Int32? = nil
    var _ramMb: Int32? = nil
    var _storageGb: Int32? = nil
    var _osType: String? = nil
    var _osVersion: String? = nil
    var _ipAddress: String? = nil
    var _macAddress: String? = nil
    var _tags: [String] = []
    var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _organizationID = source._organizationID
      _parentAssetID = source._parentAssetID
      _name = source._name
      _details = source._details
      _assetType = source._assetType
      _blobStorageURL = source._blobStorageURL
      _blobContentType = source._blobContentType
      _blobSizeBytes = source._blobSizeBytes
      _blobMetadata = source._blobMetadata
      _isComputeDevice = source._isComputeDevice
      _deviceType = source._deviceType
      _architecture = source._architecture
      _cpuCores = source._cpuCores
      _ramMb = source._ramMb
      _storageGb = source._storageGb
      _osType = source._osType
      _osVersion = source._osVersion
      _ipAddress = source._ipAddress
      _macAddress = source._macAddress
      _tags = source._tags
      _createdAt = source._createdAt
      _updatedAt = source._updatedAt
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt32Field(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularInt32Field(value: &_storage._organizationID) }()
        case 3: try { try decoder.decodeSingularInt32Field(value: &_storage._parentAssetID) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._details) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._assetType) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._blobStorageURL) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._blobContentType) }()
        case 9: try { try decoder.decodeSingularInt64Field(value: &_storage._blobSizeBytes) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._blobMetadata) }()
        case 11: try { try decoder.decodeSingularBoolField(value: &_storage._isComputeDevice) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._deviceType) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._architecture) }()
        case 14: try { try decoder.decodeSingularInt32Field(value: &_storage._cpuCores) }()
        case 15: try { try decoder.decodeSingularInt32Field(value: &_storage._ramMb) }()
        case 16: try { try decoder.decodeSingularInt32Field(value: &_storage._storageGb) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._osType) }()
        case 18: try { try decoder.decodeSingularStringField(value: &_storage._osVersion) }()
        case 19: try { try decoder.decodeSingularStringField(value: &_storage._ipAddress) }()
        case 20: try { try decoder.decodeSingularStringField(value: &_storage._macAddress) }()
        case 21: try { try decoder.decodeSingularMessageField(value: &_storage._createdAt) }()
        case 22: try { try decoder.decodeSingularMessageField(value: &_storage._updatedAt) }()
        case 23: try { try decoder.decodeRepeatedStringField(value: &_storage._tags) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._id != 0 {
        try visitor.visitSingularInt32Field(value: _storage._id, fieldNumber: 1)
      }
      if _storage._organizationID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._organizationID, fieldNumber: 2)
      }
      try { if let v = _storage._parentAssetID {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
      } }()
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 4)
      }
      if !_storage._details.isEmpty {
        try visitor.visitSingularStringField(value: _storage._details, fieldNumber: 5)
      }
      if !_storage._assetType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._assetType, fieldNumber: 6)
      }
      try { if let v = _storage._blobStorageURL {
        try visitor.visitSingularStringField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._blobContentType {
        try visitor.visitSingularStringField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._blobSizeBytes {
        try visitor.visitSingularInt64Field(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._blobMetadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      if _storage._isComputeDevice != false {
        try visitor.visitSingularBoolField(value: _storage._isComputeDevice, fieldNumber: 11)
      }
      try { if let v = _storage._deviceType {
        try visitor.visitSingularStringField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._architecture {
        try visitor.visitSingularStringField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._cpuCores {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._ramMb {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._storageGb {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._osType {
        try visitor.visitSingularStringField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._osVersion {
        try visitor.visitSingularStringField(value: v, fieldNumber: 18)
      } }()
      try { if let v = _storage._ipAddress {
        try visitor.visitSingularStringField(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._macAddress {
        try visitor.visitSingularStringField(value: v, fieldNumber: 20)
      } }()
      try { if let v = _storage._createdAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      } }()
      try { if let v = _storage._updatedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      } }()
      if !_storage._tags.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._tags, fieldNumber: 23)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Wendycloud_V1_Asset, rhs: Wendycloud_V1_Asset) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._organizationID != rhs_storage._organizationID {return false}
        if _storage._parentAssetID != rhs_storage._parentAssetID {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._details != rhs_storage._details {return false}
        if _storage._assetType != rhs_storage._assetType {return false}
        if _storage._blobStorageURL != rhs_storage._blobStorageURL {return false}
        if _storage._blobContentType != rhs_storage._blobContentType {return false}
        if _storage._blobSizeBytes != rhs_storage._blobSizeBytes {return false}
        if _storage._blobMetadata != rhs_storage._blobMetadata {return false}
        if _storage._isComputeDevice != rhs_storage._isComputeDevice {return false}
        if _storage._deviceType != rhs_storage._deviceType {return false}
        if _storage._architecture != rhs_storage._architecture {return false}
        if _storage._cpuCores != rhs_storage._cpuCores {return false}
        if _storage._ramMb != rhs_storage._ramMb {return false}
        if _storage._storageGb != rhs_storage._storageGb {return false}
        if _storage._osType != rhs_storage._osType {return false}
        if _storage._osVersion != rhs_storage._osVersion {return false}
        if _storage._ipAddress != rhs_storage._ipAddress {return false}
        if _storage._macAddress != rhs_storage._macAddress {return false}
        if _storage._tags != rhs_storage._tags {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._updatedAt != rhs_storage._updatedAt {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Wendycloud_V1_CreateAssetRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateAssetRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}organization_id\0\u{3}parent_asset_id\0\u{1}name\0\u{1}details\0\u{3}asset_type\0\u{3}blob_storage_url\0\u{3}blob_content_type\0\u{3}blob_size_bytes\0\u{3}blob_metadata\0\u{3}is_compute_device\0\u{3}device_type\0\u{1}architecture\0\u{3}cpu_cores\0\u{3}ram_mb\0\u{3}storage_gb\0\u{3}os_type\0\u{3}os_version\0\u{3}ip_address\0\u{3}mac_address\0\u{1}tags\0")

  fileprivate class _StorageClass {
    var _organizationID: Int32 = 0
    var _parentAssetID: Int32? = nil
    var _name: String = String()
    var _details: String = String()
    var _assetType: String = String()
    var _blobStorageURL: String? = nil
    var _blobContentType: String? = nil
    var _blobSizeBytes: Int64? = nil
    var _blobMetadata: SwiftProtobuf.Google_Protobuf_Struct? = nil
    var _isComputeDevice: Bool = false
    var _deviceType: String? = nil
    var _architecture: String? = nil
    var _cpuCores: Int32? = nil
    var _ramMb: Int32? = nil
    var _storageGb: Int32? = nil
    var _osType: String? = nil
    var _osVersion: String? = nil
    var _ipAddress: String? = nil
    var _macAddress: String? = nil
    var _tags: [String] = []

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _organizationID = source._organizationID
      _parentAssetID = source._parentAssetID
      _name = source._name
      _details = source._details
      _assetType = source._assetType
      _blobStorageURL = source._blobStorageURL
      _blobContentType = source._blobContentType
      _blobSizeBytes = source._blobSizeBytes
      _blobMetadata = source._blobMetadata
      _isComputeDevice = source._isComputeDevice
      _deviceType = source._deviceType
      _architecture = source._architecture
      _cpuCores = source._cpuCores
      _ramMb = source._ramMb
      _storageGb = source._storageGb
      _osType = source._osType
      _osVersion = source._osVersion
      _ipAddress = source._ipAddress
      _macAddress = source._macAddress
      _tags = source._tags
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt32Field(value: &_storage._organizationID) }()
        case 2: try { try decoder.decodeSingularInt32Field(value: &_storage._parentAssetID) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._details) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._assetType) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._blobStorageURL) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._blobContentType) }()
        case 8: try { try decoder.decodeSingularInt64Field(value: &_storage._blobSizeBytes) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._blobMetadata) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._isComputeDevice) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._deviceType) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._architecture) }()
        case 13: try { try decoder.decodeSingularInt32Field(value: &_storage._cpuCores) }()
        case 14: try { try decoder.decodeSingularInt32Field(value: &_storage._ramMb) }()
        case 15: try { try decoder.decodeSingularInt32Field(value: &_storage._storageGb) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._osType) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._osVersion) }()
        case 18: try { try decoder.decodeSingularStringField(value: &_storage._ipAddress) }()
        case 19: try { try decoder.decodeSingularStringField(value: &_storage._macAddress) }()
        case 20: try { try decoder.decodeRepeatedStringField(value: &_storage._tags) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._organizationID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._organizationID, fieldNumber: 1)
      }
      try { if let v = _storage._parentAssetID {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
      } }()
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 3)
      }
      if !_storage._details.isEmpty {
        try visitor.visitSingularStringField(value: _storage._details, fieldNumber: 4)
      }
      if !_storage._assetType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._assetType, fieldNumber: 5)
      }
      try { if let v = _storage._blobStorageURL {
        try visitor.visitSingularStringField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._blobContentType {
        try visitor.visitSingularStringField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._blobSizeBytes {
        try visitor.visitSingularInt64Field(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._blobMetadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      if _storage._isComputeDevice != false {
        try visitor.visitSingularBoolField(value: _storage._isComputeDevice, fieldNumber: 10)
      }
      try { if let v = _storage._deviceType {
        try visitor.visitSingularStringField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._architecture {
        try visitor.visitSingularStringField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._cpuCores {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._ramMb {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._storageGb {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._osType {
        try visitor.visitSingularStringField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._osVersion {
        try visitor.visitSingularStringField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._ipAddress {
        try visitor.visitSingularStringField(value: v, fieldNumber: 18)
      } }()
      try { if let v = _storage._macAddress {
        try visitor.visitSingularStringField(value: v, fieldNumber: 19)
      } }()
      if !_storage._tags.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._tags, fieldNumber: 20)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Wendycloud_V1_CreateAssetRequest, rhs: Wendycloud_V1_CreateAssetRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._organizationID != rhs_storage._organizationID {return false}
        if _storage._parentAssetID != rhs_storage._parentAssetID {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._details != rhs_storage._details {return false}
        if _storage._assetType != rhs_storage._assetType {return false}
        if _storage._blobStorageURL != rhs_storage._blobStorageURL {return false}
        if _storage._blobContentType != rhs_storage._blobContentType {return false}
        if _storage._blobSizeBytes != rhs_storage._blobSizeBytes {return false}
        if _storage._blobMetadata != rhs_storage._blobMetadata {return false}
        if _storage._isComputeDevice != rhs_storage._isComputeDevice {return false}
        if _storage._deviceType != rhs_storage._deviceType {return false}
        if _storage._architecture != rhs_storage._architecture {return false}
        if _storage._cpuCores != rhs_storage._cpuCores {return false}
        if _storage._ramMb != rhs_storage._ramMb {return false}
        if _storage._storageGb != rhs_storage._storageGb {return false}
        if _storage._osType != rhs_storage._osType {return false}
        if _storage._osVersion != rhs_storage._osVersion {return false}
        if _storage._ipAddress != rhs_storage._ipAddress {return false}
        if _storage._macAddress != rhs_storage._macAddress {return false}
        if _storage._tags != rhs_storage._tags {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Wendycloud_V1_GetAssetRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetAssetRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Wendycloud_V1_GetAssetRequest, rhs: Wendycloud_V1_GetAssetRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Wendycloud_V1_UpdateAssetRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateAssetRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}name\0\u{1}details\0\u{3}blob_storage_url\0\u{3}blob_content_type\0\u{3}blob_size_bytes\0\u{3}blob_metadata\0\u{3}device_type\0\u{1}architecture\0\u{3}cpu_cores\0\u{3}ram_mb\0\u{3}storage_gb\0\u{3}os_type\0\u{3}os_version\0\u{3}ip_address\0\u{3}mac_address\0\u{1}tags\0")

  fileprivate class _StorageClass {
    var _id: Int32 = 0
    var _name: String? = nil
    var _details: String? = nil
    var _blobStorageURL: String? = nil
    var _blobContentType: String? = nil
    var _blobSizeBytes: Int64? = nil
    var _blobMetadata: SwiftProtobuf.Google_Protobuf_Struct? = nil
    var _deviceType: String? = nil
    var _architecture: String? = nil
    var _cpuCores: Int32? = nil
    var _ramMb: Int32? = nil
    var _storageGb: Int32? = nil
    var _osType: String? = nil
    var _osVersion: String? = nil
    var _ipAddress: String? = nil
    var _macAddress: String? = nil
    var _tags: [String] = []

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _name = source._name
      _details = source._details
      _blobStorageURL = source._blobStorageURL
      _blobContentType = source._blobContentType
      _blobSizeBytes = source._blobSizeBytes
      _blobMetadata = source._blobMetadata
      _deviceType = source._deviceType
      _architecture = source._architecture
      _cpuCores = source._cpuCores
      _ramMb = source._ramMb
      _storageGb = source._storageGb
      _osType = source._osType
      _osVersion = source._osVersion
      _ipAddress = source._ipAddress
      _macAddress = source._macAddress
      _tags = source._tags
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt32Field(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._details) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._blobStorageURL) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._blobContentType) }()
        case 6: try { try decoder.decodeSingularInt64Field(value: &_storage._blobSizeBytes) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._blobMetadata) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._deviceType) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._architecture) }()
        case 10: try { try decoder.decodeSingularInt32Field(value: &_storage._cpuCores) }()
        case 11: try { try decoder.decodeSingularInt32Field(value: &_storage._ramMb) }()
        case 12: try { try decoder.decodeSingularInt32Field(value: &_storage._storageGb) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._osType) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._osVersion) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._ipAddress) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._macAddress) }()
        case 17: try { try decoder.decodeRepeatedStringField(value: &_storage._tags) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._id != 0 {
        try visitor.visitSingularInt32Field(value: _storage._id, fieldNumber: 1)
      }
      try { if let v = _storage._name {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._details {
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._blobStorageURL {
        try visitor.visitSingularStringField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._blobContentType {
        try visitor.visitSingularStringField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._blobSizeBytes {
        try visitor.visitSingularInt64Field(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._blobMetadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._deviceType {
        try visitor.visitSingularStringField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._architecture {
        try visitor.visitSingularStringField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._cpuCores {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._ramMb {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._storageGb {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._osType {
        try visitor.visitSingularStringField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._osVersion {
        try visitor.visitSingularStringField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._ipAddress {
        try visitor.visitSingularStringField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._macAddress {
        try visitor.visitSingularStringField(value: v, fieldNumber: 16)
      } }()
      if !_storage._tags.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._tags, fieldNumber: 17)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Wendycloud_V1_UpdateAssetRequest, rhs: Wendycloud_V1_UpdateAssetRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._details != rhs_storage._details {return false}
        if _storage._blobStorageURL != rhs_storage._blobStorageURL {return false}
        if _storage._blobContentType != rhs_storage._blobContentType {return false}
        if _storage._blobSizeBytes != rhs_storage._blobSizeBytes {return false}
        if _storage._blobMetadata != rhs_storage._blobMetadata {return false}
        if _storage._deviceType != rhs_storage._deviceType {return false}
        if _storage._architecture != rhs_storage._architecture {return false}
        if _storage._cpuCores != rhs_storage._cpuCores {return false}
        if _storage._ramMb != rhs_storage._ramMb {return false}
        if _storage._storageGb != rhs_storage._storageGb {return false}
        if _storage._osType != rhs_storage._osType {return false}
        if _storage._osVersion != rhs_storage._osVersion {return false}
        if _storage._ipAddress != rhs_storage._ipAddress {return false}
        if _storage._macAddress != rhs_storage._macAddress {return false}
        if _storage._tags != rhs_storage._tags {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Wendycloud_V1_DeleteAssetRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteAssetRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Wendycloud_V1_DeleteAssetRequest, rhs: Wendycloud_V1_DeleteAssetRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Wendycloud_V1_DeleteAssetResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteAssetResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Wendycloud_V1_DeleteAssetResponse, rhs: Wendycloud_V1_DeleteAssetResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Wendycloud_V1_ListAssetsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListAssetsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}organization_id\0\u{3}is_compute_device\0\u{3}page_size\0\u{3}page_token\0\u{1}filter\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.organizationID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._isComputeDevice) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._filter) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.organizationID != 0 {
      try visitor.visitSingularInt32Field(value: self.organizationID, fieldNumber: 1)
    }
    try { if let v = self._isComputeDevice {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 3)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 4)
    }
    try { if let v = self._filter {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Wendycloud_V1_ListAssetsRequest, rhs: Wendycloud_V1_ListAssetsRequest) -> Bool {
    if lhs.organizationID != rhs.organizationID {return false}
    if lhs._isComputeDevice != rhs._isComputeDevice {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs._filter != rhs._filter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Wendycloud_V1_ListAssetsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListAssetsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}assets\0\u{3}next_page_token\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.assets) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.assets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.assets, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Wendycloud_V1_ListAssetsResponse, rhs: Wendycloud_V1_ListAssetsResponse) -> Bool {
    if lhs.assets != rhs.assets {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Wendycloud_V1_ListAssetChildrenRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListAssetChildrenRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}parent_asset_id\0\u{3}page_size\0\u{3}page_token\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.parentAssetID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.parentAssetID != 0 {
      try visitor.visitSingularInt32Field(value: self.parentAssetID, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Wendycloud_V1_ListAssetChildrenRequest, rhs: Wendycloud_V1_ListAssetChildrenRequest) -> Bool {
    if lhs.parentAssetID != rhs.parentAssetID {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Wendycloud_V1_ListAssetChildrenResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListAssetChildrenResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}assets\0\u{3}next_page_token\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.assets) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.assets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.assets, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Wendycloud_V1_ListAssetChildrenResponse, rhs: Wendycloud_V1_ListAssetChildrenResponse) -> Bool {
    if lhs.assets != rhs.assets {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Wendycloud_V1_GetAssetLineageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetAssetLineageRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}asset_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.assetID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.assetID != 0 {
      try visitor.visitSingularInt32Field(value: self.assetID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Wendycloud_V1_GetAssetLineageRequest, rhs: Wendycloud_V1_GetAssetLineageRequest) -> Bool {
    if lhs.assetID != rhs.assetID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Wendycloud_V1_GetAssetLineageResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetAssetLineageResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}root_asset\0\u{3}all_assets\0\u{3}requested_asset_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._rootAsset) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.allAssets) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.requestedAssetID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._rootAsset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.allAssets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.allAssets, fieldNumber: 2)
    }
    if self.requestedAssetID != 0 {
      try visitor.visitSingularInt32Field(value: self.requestedAssetID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Wendycloud_V1_GetAssetLineageResponse, rhs: Wendycloud_V1_GetAssetLineageResponse) -> Bool {
    if lhs._rootAsset != rhs._rootAsset {return false}
    if lhs.allAssets != rhs.allAssets {return false}
    if lhs.requestedAssetID != rhs.requestedAssetID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
