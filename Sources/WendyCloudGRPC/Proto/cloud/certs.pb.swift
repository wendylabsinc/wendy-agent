// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: cloud/certs.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Wendycloud_V1_CertificateStatus: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unspecified // = 0
  case active // = 1
  case revoked // = 2
  case expired // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .active
    case 2: self = .revoked
    case 3: self = .expired
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .active: return 1
    case .revoked: return 2
    case .expired: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Wendycloud_V1_CertificateStatus] = [
    .unspecified,
    .active,
    .revoked,
    .expired,
  ]

}

/// Represents a persisted certificate record.
public struct Wendycloud_V1_Certificate: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int32 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var organizationID: Int32 {
    get {return _storage._organizationID}
    set {_uniqueStorage()._organizationID = newValue}
  }

  public var assetID: Int32 {
    get {return _storage._assetID}
    set {_uniqueStorage()._assetID = newValue}
  }

  public var serialNumber: String {
    get {return _storage._serialNumber}
    set {_uniqueStorage()._serialNumber = newValue}
  }

  /// Leaf certificate (PEM)
  public var pemCertificate: String {
    get {return _storage._pemCertificate}
    set {_uniqueStorage()._pemCertificate = newValue}
  }

  /// Chain including issuer(s) (PEM)
  public var pemCertificateChain: String {
    get {return _storage._pemCertificateChain}
    set {_uniqueStorage()._pemCertificateChain = newValue}
  }

  public var notBefore: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._notBefore ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._notBefore = newValue}
  }
  /// Returns true if `notBefore` has been explicitly set.
  public var hasNotBefore: Bool {return _storage._notBefore != nil}
  /// Clears the value of `notBefore`. Subsequent reads from it will return its default value.
  public mutating func clearNotBefore() {_uniqueStorage()._notBefore = nil}

  public var notAfter: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._notAfter ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._notAfter = newValue}
  }
  /// Returns true if `notAfter` has been explicitly set.
  public var hasNotAfter: Bool {return _storage._notAfter != nil}
  /// Clears the value of `notAfter`. Subsequent reads from it will return its default value.
  public mutating func clearNotAfter() {_uniqueStorage()._notAfter = nil}

  public var status: Wendycloud_V1_CertificateStatus {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  /// if revoked
  public var revokedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._revokedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._revokedAt = newValue}
  }
  /// Returns true if `revokedAt` has been explicitly set.
  public var hasRevokedAt: Bool {return _storage._revokedAt != nil}
  /// Clears the value of `revokedAt`. Subsequent reads from it will return its default value.
  public mutating func clearRevokedAt() {_uniqueStorage()._revokedAt = nil}

  /// free-form for now
  public var revocationReason: String {
    get {return _storage._revocationReason}
    set {_uniqueStorage()._revocationReason = newValue}
  }

  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return _storage._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {_uniqueStorage()._createdAt = nil}

  public var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  public var hasUpdatedAt: Bool {return _storage._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  public mutating func clearUpdatedAt() {_uniqueStorage()._updatedAt = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Required for issuing a certificate for the first time for an asset
/// you can look up the assetId and organizationId by the enrollment token
public struct Wendycloud_V1_IssueCertificateRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// PKCS#10 CSR (PEM)
  public var pemCsr: String = String()

  /// For device provisioning (no Firebase on device)
  public var enrollmentToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Used by an authenticated asset (via mTLS) to rotate its certificate.
/// The server extracts organization_id and asset_id from the client's current
/// certificate SAN (Subject Alternative Name), so they don't need to be provided.
/// The agent should refresh ~2/3 through the current certificate's lifetime.
public struct Wendycloud_V1_RefreshCertificateRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// New CSR with new public key (PKCS#10 PEM)
  public var pemCsr: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Wendycloud_V1_RevokeCertificateRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var certificateID: Int32 = 0

  public var reason: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Wendycloud_V1_RevokeCertificateResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var success: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Wendycloud_V1_GetCertificateRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var certificateID: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Wendycloud_V1_ListCertificatesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var assetID: Int32 = 0

  public var pageSize: Int32 = 0

  public var pageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Wendycloud_V1_ListCertificatesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var certificates: [Wendycloud_V1_Certificate] = []

  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Wendycloud_V1_GetCaBundleRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Wendycloud_V1_GetCaBundleResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// PEM-encoded concatenated root/issuer chain used by clients to build trust.
  public var pemBundle: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Enrollment token RPCs
public struct Wendycloud_V1_CreateEnrollmentTokenRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var organizationID: Int32 = 0

  /// Optional: restrict to an existing asset; if omitted, asset can be created at issuance time
  public var assetID: Int32 = 0

  /// Lifetime in seconds (default server policy, e.g., 600s)
  public var ttlSeconds: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Wendycloud_V1_CreateEnrollmentTokenResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Opaque signed token the agent will use
  public var enrollmentToken: String = String()

  /// Token id for auditing
  public var jti: String = String()

  public var expiresAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _expiresAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_expiresAt = newValue}
  }
  /// Returns true if `expiresAt` has been explicitly set.
  public var hasExpiresAt: Bool {return self._expiresAt != nil}
  /// Clears the value of `expiresAt`. Subsequent reads from it will return its default value.
  public mutating func clearExpiresAt() {self._expiresAt = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _expiresAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "wendycloud.v1"

extension Wendycloud_V1_CertificateStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0CERTIFICATE_STATUS_UNSPECIFIED\0\u{1}CERTIFICATE_STATUS_ACTIVE\0\u{1}CERTIFICATE_STATUS_REVOKED\0\u{1}CERTIFICATE_STATUS_EXPIRED\0")
}

extension Wendycloud_V1_Certificate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Certificate"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{3}organization_id\0\u{3}asset_id\0\u{3}serial_number\0\u{3}pem_certificate\0\u{3}pem_certificate_chain\0\u{3}not_before\0\u{3}not_after\0\u{1}status\0\u{3}revoked_at\0\u{3}revocation_reason\0\u{3}created_at\0\u{3}updated_at\0")

  fileprivate class _StorageClass {
    var _id: Int32 = 0
    var _organizationID: Int32 = 0
    var _assetID: Int32 = 0
    var _serialNumber: String = String()
    var _pemCertificate: String = String()
    var _pemCertificateChain: String = String()
    var _notBefore: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _notAfter: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _status: Wendycloud_V1_CertificateStatus = .unspecified
    var _revokedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _revocationReason: String = String()
    var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _organizationID = source._organizationID
      _assetID = source._assetID
      _serialNumber = source._serialNumber
      _pemCertificate = source._pemCertificate
      _pemCertificateChain = source._pemCertificateChain
      _notBefore = source._notBefore
      _notAfter = source._notAfter
      _status = source._status
      _revokedAt = source._revokedAt
      _revocationReason = source._revocationReason
      _createdAt = source._createdAt
      _updatedAt = source._updatedAt
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt32Field(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularInt32Field(value: &_storage._organizationID) }()
        case 3: try { try decoder.decodeSingularInt32Field(value: &_storage._assetID) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._serialNumber) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._pemCertificate) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._pemCertificateChain) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._notBefore) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._notAfter) }()
        case 9: try { try decoder.decodeSingularEnumField(value: &_storage._status) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._revokedAt) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._revocationReason) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._createdAt) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._updatedAt) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._id != 0 {
        try visitor.visitSingularInt32Field(value: _storage._id, fieldNumber: 1)
      }
      if _storage._organizationID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._organizationID, fieldNumber: 2)
      }
      if _storage._assetID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._assetID, fieldNumber: 3)
      }
      if !_storage._serialNumber.isEmpty {
        try visitor.visitSingularStringField(value: _storage._serialNumber, fieldNumber: 4)
      }
      if !_storage._pemCertificate.isEmpty {
        try visitor.visitSingularStringField(value: _storage._pemCertificate, fieldNumber: 5)
      }
      if !_storage._pemCertificateChain.isEmpty {
        try visitor.visitSingularStringField(value: _storage._pemCertificateChain, fieldNumber: 6)
      }
      try { if let v = _storage._notBefore {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._notAfter {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if _storage._status != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._status, fieldNumber: 9)
      }
      try { if let v = _storage._revokedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      if !_storage._revocationReason.isEmpty {
        try visitor.visitSingularStringField(value: _storage._revocationReason, fieldNumber: 11)
      }
      try { if let v = _storage._createdAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._updatedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Wendycloud_V1_Certificate, rhs: Wendycloud_V1_Certificate) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._organizationID != rhs_storage._organizationID {return false}
        if _storage._assetID != rhs_storage._assetID {return false}
        if _storage._serialNumber != rhs_storage._serialNumber {return false}
        if _storage._pemCertificate != rhs_storage._pemCertificate {return false}
        if _storage._pemCertificateChain != rhs_storage._pemCertificateChain {return false}
        if _storage._notBefore != rhs_storage._notBefore {return false}
        if _storage._notAfter != rhs_storage._notAfter {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._revokedAt != rhs_storage._revokedAt {return false}
        if _storage._revocationReason != rhs_storage._revocationReason {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._updatedAt != rhs_storage._updatedAt {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Wendycloud_V1_IssueCertificateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IssueCertificateRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{4}\u{3}pem_csr\0\u{4}\u{2}enrollment_token\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3: try { try decoder.decodeSingularStringField(value: &self.pemCsr) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.enrollmentToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pemCsr.isEmpty {
      try visitor.visitSingularStringField(value: self.pemCsr, fieldNumber: 3)
    }
    if !self.enrollmentToken.isEmpty {
      try visitor.visitSingularStringField(value: self.enrollmentToken, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Wendycloud_V1_IssueCertificateRequest, rhs: Wendycloud_V1_IssueCertificateRequest) -> Bool {
    if lhs.pemCsr != rhs.pemCsr {return false}
    if lhs.enrollmentToken != rhs.enrollmentToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Wendycloud_V1_RefreshCertificateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RefreshCertificateRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{4}\u{3}pem_csr\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3: try { try decoder.decodeSingularStringField(value: &self.pemCsr) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pemCsr.isEmpty {
      try visitor.visitSingularStringField(value: self.pemCsr, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Wendycloud_V1_RefreshCertificateRequest, rhs: Wendycloud_V1_RefreshCertificateRequest) -> Bool {
    if lhs.pemCsr != rhs.pemCsr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Wendycloud_V1_RevokeCertificateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RevokeCertificateRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}certificate_id\0\u{1}reason\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.certificateID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.certificateID != 0 {
      try visitor.visitSingularInt32Field(value: self.certificateID, fieldNumber: 1)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Wendycloud_V1_RevokeCertificateRequest, rhs: Wendycloud_V1_RevokeCertificateRequest) -> Bool {
    if lhs.certificateID != rhs.certificateID {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Wendycloud_V1_RevokeCertificateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RevokeCertificateResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Wendycloud_V1_RevokeCertificateResponse, rhs: Wendycloud_V1_RevokeCertificateResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Wendycloud_V1_GetCertificateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetCertificateRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}certificate_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.certificateID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.certificateID != 0 {
      try visitor.visitSingularInt32Field(value: self.certificateID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Wendycloud_V1_GetCertificateRequest, rhs: Wendycloud_V1_GetCertificateRequest) -> Bool {
    if lhs.certificateID != rhs.certificateID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Wendycloud_V1_ListCertificatesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListCertificatesRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}asset_id\0\u{3}page_size\0\u{3}page_token\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.assetID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.assetID != 0 {
      try visitor.visitSingularInt32Field(value: self.assetID, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Wendycloud_V1_ListCertificatesRequest, rhs: Wendycloud_V1_ListCertificatesRequest) -> Bool {
    if lhs.assetID != rhs.assetID {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Wendycloud_V1_ListCertificatesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListCertificatesResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}certificates\0\u{3}next_page_token\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.certificates) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.certificates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.certificates, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Wendycloud_V1_ListCertificatesResponse, rhs: Wendycloud_V1_ListCertificatesResponse) -> Bool {
    if lhs.certificates != rhs.certificates {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Wendycloud_V1_GetCaBundleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetCaBundleRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Wendycloud_V1_GetCaBundleRequest, rhs: Wendycloud_V1_GetCaBundleRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Wendycloud_V1_GetCaBundleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetCaBundleResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}pem_bundle\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pemBundle) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pemBundle.isEmpty {
      try visitor.visitSingularStringField(value: self.pemBundle, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Wendycloud_V1_GetCaBundleResponse, rhs: Wendycloud_V1_GetCaBundleResponse) -> Bool {
    if lhs.pemBundle != rhs.pemBundle {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Wendycloud_V1_CreateEnrollmentTokenRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateEnrollmentTokenRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}organization_id\0\u{3}asset_id\0\u{3}ttl_seconds\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.organizationID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.assetID) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.ttlSeconds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.organizationID != 0 {
      try visitor.visitSingularInt32Field(value: self.organizationID, fieldNumber: 1)
    }
    if self.assetID != 0 {
      try visitor.visitSingularInt32Field(value: self.assetID, fieldNumber: 2)
    }
    if self.ttlSeconds != 0 {
      try visitor.visitSingularInt32Field(value: self.ttlSeconds, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Wendycloud_V1_CreateEnrollmentTokenRequest, rhs: Wendycloud_V1_CreateEnrollmentTokenRequest) -> Bool {
    if lhs.organizationID != rhs.organizationID {return false}
    if lhs.assetID != rhs.assetID {return false}
    if lhs.ttlSeconds != rhs.ttlSeconds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Wendycloud_V1_CreateEnrollmentTokenResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateEnrollmentTokenResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}enrollment_token\0\u{1}jti\0\u{3}expires_at\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.enrollmentToken) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.jti) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._expiresAt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.enrollmentToken.isEmpty {
      try visitor.visitSingularStringField(value: self.enrollmentToken, fieldNumber: 1)
    }
    if !self.jti.isEmpty {
      try visitor.visitSingularStringField(value: self.jti, fieldNumber: 2)
    }
    try { if let v = self._expiresAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Wendycloud_V1_CreateEnrollmentTokenResponse, rhs: Wendycloud_V1_CreateEnrollmentTokenResponse) -> Bool {
    if lhs.enrollmentToken != rhs.enrollmentToken {return false}
    if lhs.jti != rhs.jti {return false}
    if lhs._expiresAt != rhs._expiresAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
