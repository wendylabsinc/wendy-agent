// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: cloud/certificates.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Wendycloud_V1_CertificateStatus: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unspecified // = 0
  case active // = 1
  case revoked // = 2
  case expired // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .active
    case 2: self = .revoked
    case 3: self = .expired
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .active: return 1
    case .revoked: return 2
    case .expired: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Wendycloud_V1_CertificateStatus] = [
    .unspecified,
    .active,
    .revoked,
    .expired,
  ]

}

/// Error codes for certificate operations
public enum Wendycloud_V1_CertificateErrorCode: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case certificateErrorUnspecified // = 0

  /// CSR parsing/validation failed
  case certificateErrorInvalidCsr // = 1

  /// Token expired or invalid
  case certificateErrorInvalidEnrollmentToken // = 2

  /// Missing or invalid auth
  case certificateErrorUnauthorized // = 3

  /// Organization doesn't exist
  case certificateErrorOrganizationNotFound // = 4

  /// Asset doesn't exist
  case certificateErrorAssetNotFound // = 5

  /// GCP CAS issue
  case certificateErrorCaServiceUnavailable // = 6

  /// Rate limiting
  case certificateErrorQuotaExceeded // = 7

  /// Trying to refresh revoked cert
  case certificateErrorCertificateRevoked // = 8

  /// Trying to refresh expired cert
  case certificateErrorCertificateExpired // = 9

  /// CSR CN doesn't match requirements
  case certificateErrorInvalidCommonName // = 10

  /// Internal server error
  case certificateErrorInternal // = 11
  case UNRECOGNIZED(Int)

  public init() {
    self = .certificateErrorUnspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .certificateErrorUnspecified
    case 1: self = .certificateErrorInvalidCsr
    case 2: self = .certificateErrorInvalidEnrollmentToken
    case 3: self = .certificateErrorUnauthorized
    case 4: self = .certificateErrorOrganizationNotFound
    case 5: self = .certificateErrorAssetNotFound
    case 6: self = .certificateErrorCaServiceUnavailable
    case 7: self = .certificateErrorQuotaExceeded
    case 8: self = .certificateErrorCertificateRevoked
    case 9: self = .certificateErrorCertificateExpired
    case 10: self = .certificateErrorInvalidCommonName
    case 11: self = .certificateErrorInternal
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .certificateErrorUnspecified: return 0
    case .certificateErrorInvalidCsr: return 1
    case .certificateErrorInvalidEnrollmentToken: return 2
    case .certificateErrorUnauthorized: return 3
    case .certificateErrorOrganizationNotFound: return 4
    case .certificateErrorAssetNotFound: return 5
    case .certificateErrorCaServiceUnavailable: return 6
    case .certificateErrorQuotaExceeded: return 7
    case .certificateErrorCertificateRevoked: return 8
    case .certificateErrorCertificateExpired: return 9
    case .certificateErrorInvalidCommonName: return 10
    case .certificateErrorInternal: return 11
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Wendycloud_V1_CertificateErrorCode] = [
    .certificateErrorUnspecified,
    .certificateErrorInvalidCsr,
    .certificateErrorInvalidEnrollmentToken,
    .certificateErrorUnauthorized,
    .certificateErrorOrganizationNotFound,
    .certificateErrorAssetNotFound,
    .certificateErrorCaServiceUnavailable,
    .certificateErrorQuotaExceeded,
    .certificateErrorCertificateRevoked,
    .certificateErrorCertificateExpired,
    .certificateErrorInvalidCommonName,
    .certificateErrorInternal,
  ]

}

public struct Wendycloud_V1_GetCertificateMetadataRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Wendycloud_V1_GetCertificateMetadataResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Always present for all certificate types
  public var organizationID: Int32 = 0

  /// Set if this is an asset certificate
  public var assetID: Int32 {
    get {return _assetID ?? 0}
    set {_assetID = newValue}
  }
  /// Returns true if `assetID` has been explicitly set.
  public var hasAssetID: Bool {return self._assetID != nil}
  /// Clears the value of `assetID`. Subsequent reads from it will return its default value.
  public mutating func clearAssetID() {self._assetID = nil}

  /// Set if this is a user certificate
  public var userID: String {
    get {return _userID ?? String()}
    set {_userID = newValue}
  }
  /// Returns true if `userID` has been explicitly set.
  public var hasUserID: Bool {return self._userID != nil}
  /// Clears the value of `userID`. Subsequent reads from it will return its default value.
  public mutating func clearUserID() {self._userID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _assetID: Int32? = nil
  fileprivate var _userID: String? = nil
}

/// Represents a persisted certificate record.
/// Can represent a certificate for either an asset or a user.
/// It will always have an organization_id, but may have an asset_id or user_id.
/// The asset_id and user_id are mutually exclusive.
/// If there is a certificate for `wendy-agent`, it will have an asset_id and organization_id.
/// If there is a certificate for a user, it will have a user_id and organization_id.
public struct Wendycloud_V1_Certificate: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int32 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var organizationID: Int32 {
    get {return _storage._organizationID}
    set {_uniqueStorage()._organizationID = newValue}
  }

  /// Set if this is an asset certificate
  public var assetID: Int32 {
    get {return _storage._assetID ?? 0}
    set {_uniqueStorage()._assetID = newValue}
  }
  /// Returns true if `assetID` has been explicitly set.
  public var hasAssetID: Bool {return _storage._assetID != nil}
  /// Clears the value of `assetID`. Subsequent reads from it will return its default value.
  public mutating func clearAssetID() {_uniqueStorage()._assetID = nil}

  /// Set if this is a user certificate
  public var userID: String {
    get {return _storage._userID ?? String()}
    set {_uniqueStorage()._userID = newValue}
  }
  /// Returns true if `userID` has been explicitly set.
  public var hasUserID: Bool {return _storage._userID != nil}
  /// Clears the value of `userID`. Subsequent reads from it will return its default value.
  public mutating func clearUserID() {_uniqueStorage()._userID = nil}

  public var serialNumber: String {
    get {return _storage._serialNumber}
    set {_uniqueStorage()._serialNumber = newValue}
  }

  /// Leaf certificate (PEM)
  public var pemCertificate: String {
    get {return _storage._pemCertificate}
    set {_uniqueStorage()._pemCertificate = newValue}
  }

  /// Chain including issuer(s) (PEM)
  public var pemCertificateChain: String {
    get {return _storage._pemCertificateChain}
    set {_uniqueStorage()._pemCertificateChain = newValue}
  }

  public var notBefore: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._notBefore ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._notBefore = newValue}
  }
  /// Returns true if `notBefore` has been explicitly set.
  public var hasNotBefore: Bool {return _storage._notBefore != nil}
  /// Clears the value of `notBefore`. Subsequent reads from it will return its default value.
  public mutating func clearNotBefore() {_uniqueStorage()._notBefore = nil}

  public var notAfter: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._notAfter ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._notAfter = newValue}
  }
  /// Returns true if `notAfter` has been explicitly set.
  public var hasNotAfter: Bool {return _storage._notAfter != nil}
  /// Clears the value of `notAfter`. Subsequent reads from it will return its default value.
  public mutating func clearNotAfter() {_uniqueStorage()._notAfter = nil}

  public var status: Wendycloud_V1_CertificateStatus {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  /// if revoked
  public var revokedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._revokedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._revokedAt = newValue}
  }
  /// Returns true if `revokedAt` has been explicitly set.
  public var hasRevokedAt: Bool {return _storage._revokedAt != nil}
  /// Clears the value of `revokedAt`. Subsequent reads from it will return its default value.
  public mutating func clearRevokedAt() {_uniqueStorage()._revokedAt = nil}

  /// free-form for now
  public var revocationReason: String {
    get {return _storage._revocationReason}
    set {_uniqueStorage()._revocationReason = newValue}
  }

  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return _storage._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {_uniqueStorage()._createdAt = nil}

  public var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  public var hasUpdatedAt: Bool {return _storage._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  public mutating func clearUpdatedAt() {_uniqueStorage()._updatedAt = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Required for issuing a certificate for the first time for an asset
/// you can look up the assetId and organizationId by the enrollment token
public struct Wendycloud_V1_IssueCertificateRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// PKCS#10 CSR (PEM)
  public var pemCsr: String = String()

  /// For device provisioning (no Firebase on device)
  public var enrollmentToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response wrapper with structured error handling for certificate issuance
public struct Wendycloud_V1_IssueCertificateResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If successful, contains the issued certificate
  public var certificate: Wendycloud_V1_Certificate {
    get {return _certificate ?? Wendycloud_V1_Certificate()}
    set {_certificate = newValue}
  }
  /// Returns true if `certificate` has been explicitly set.
  public var hasCertificate: Bool {return self._certificate != nil}
  /// Clears the value of `certificate`. Subsequent reads from it will return its default value.
  public mutating func clearCertificate() {self._certificate = nil}

  /// Error details if issuance failed (empty on success)
  public var error: Wendycloud_V1_CertificateError {
    get {return _error ?? Wendycloud_V1_CertificateError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  public var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  public mutating func clearError() {self._error = nil}

  /// Warnings that don't prevent issuance (e.g., CSR has unusual extensions)
  public var warnings: [String] = []

  /// Organization that owns this certificate
  public var organizationID: Int32 = 0

  /// Asset this certificate was issued for (populated when using asset enrollment token)
  public var assetID: Int32 {
    get {return _assetID ?? 0}
    set {_assetID = newValue}
  }
  /// Returns true if `assetID` has been explicitly set.
  public var hasAssetID: Bool {return self._assetID != nil}
  /// Clears the value of `assetID`. Subsequent reads from it will return its default value.
  public mutating func clearAssetID() {self._assetID = nil}

  /// User this certificate was issued for (populated when using user enrollment token)
  public var userID: String {
    get {return _userID ?? String()}
    set {_userID = newValue}
  }
  /// Returns true if `userID` has been explicitly set.
  public var hasUserID: Bool {return self._userID != nil}
  /// Clears the value of `userID`. Subsequent reads from it will return its default value.
  public mutating func clearUserID() {self._userID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _certificate: Wendycloud_V1_Certificate? = nil
  fileprivate var _error: Wendycloud_V1_CertificateError? = nil
  fileprivate var _assetID: Int32? = nil
  fileprivate var _userID: String? = nil
}

/// Used by an authenticated asset (via mTLS) to rotate its certificate.
/// The server extracts organization_id and asset_id from the client's current
/// certificate SAN (Subject Alternative Name), so they don't need to be provided.
/// The agent should refresh ~2/3 through the current certificate's lifetime.
public struct Wendycloud_V1_RefreshCertificateRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// New CSR with new public key (PKCS#10 PEM)
  public var pemCsr: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response wrapper with structured error handling for certificate refresh
public struct Wendycloud_V1_RefreshCertificateResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If successful, contains the refreshed certificate
  public var certificate: Wendycloud_V1_Certificate {
    get {return _certificate ?? Wendycloud_V1_Certificate()}
    set {_certificate = newValue}
  }
  /// Returns true if `certificate` has been explicitly set.
  public var hasCertificate: Bool {return self._certificate != nil}
  /// Clears the value of `certificate`. Subsequent reads from it will return its default value.
  public mutating func clearCertificate() {self._certificate = nil}

  /// Error details if refresh failed (empty on success)
  public var error: Wendycloud_V1_CertificateError {
    get {return _error ?? Wendycloud_V1_CertificateError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  public var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  public mutating func clearError() {self._error = nil}

  /// Warnings that don't prevent refresh
  public var warnings: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _certificate: Wendycloud_V1_Certificate? = nil
  fileprivate var _error: Wendycloud_V1_CertificateError? = nil
}

public struct Wendycloud_V1_RevokeCertificateRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var certificateID: Int32 = 0

  public var reason: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Wendycloud_V1_RevokeCertificateResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var success: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Wendycloud_V1_GetCertificateRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var certificateID: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Wendycloud_V1_ListCertificatesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var assetID: Int32 = 0

  /// Offset/limit based pagination
  public var offset: Int32 {
    get {return _offset ?? 0}
    set {_offset = newValue}
  }
  /// Returns true if `offset` has been explicitly set.
  public var hasOffset: Bool {return self._offset != nil}
  /// Clears the value of `offset`. Subsequent reads from it will return its default value.
  public mutating func clearOffset() {self._offset = nil}

  public var limit: Int32 {
    get {return _limit ?? 0}
    set {_limit = newValue}
  }
  /// Returns true if `limit` has been explicitly set.
  public var hasLimit: Bool {return self._limit != nil}
  /// Clears the value of `limit`. Subsequent reads from it will return its default value.
  public mutating func clearLimit() {self._limit = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _offset: Int32? = nil
  fileprivate var _limit: Int32? = nil
}

public struct Wendycloud_V1_ListCertificatesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// One certificate per streamed response and total count for the full query
  public var certificate: Wendycloud_V1_Certificate {
    get {return _certificate ?? Wendycloud_V1_Certificate()}
    set {_certificate = newValue}
  }
  /// Returns true if `certificate` has been explicitly set.
  public var hasCertificate: Bool {return self._certificate != nil}
  /// Clears the value of `certificate`. Subsequent reads from it will return its default value.
  public mutating func clearCertificate() {self._certificate = nil}

  public var total: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _certificate: Wendycloud_V1_Certificate? = nil
}

public struct Wendycloud_V1_GetCaBundleRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Wendycloud_V1_GetCaBundleResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// PEM-encoded concatenated root/issuer chain used by clients to build trust.
  public var pemBundle: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Asset Enrollment Token RPCs
/// This DOES use the Authorization: Bearer token since it's generated primarily by a user logged into the dashboard
public struct Wendycloud_V1_CreateAssetEnrollmentTokenRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var organizationID: Int32 = 0

  public var name: String = String()

  /// Lifetime in seconds (default server policy, e.g., 600s)
  public var ttlSeconds: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Wendycloud_V1_CreateAssetEnrollmentTokenResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Opaque signed token the agent will use
  public var enrollmentToken: String = String()

  /// Token id for auditing
  public var jti: String = String()

  public var expiresAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _expiresAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_expiresAt = newValue}
  }
  /// Returns true if `expiresAt` has been explicitly set.
  public var hasExpiresAt: Bool {return self._expiresAt != nil}
  /// Clears the value of `expiresAt`. Subsequent reads from it will return its default value.
  public mutating func clearExpiresAt() {self._expiresAt = nil}

  /// Organization this token belongs to
  public var organizationID: Int32 = 0

  /// Asset this token is for
  public var assetID: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _expiresAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// User Enrollment Token RPCs
/// This DOES use the Authorization: Bearer token since it's generated primarily by a user logged into the dashboard
/// The user_id is derived from the Authorization: Bearer token (Firebase ID token)
public struct Wendycloud_V1_CreateUserEnrollmentTokenRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Lifetime in seconds (default server policy, e.g., 600s)
  public var ttlSeconds: Int32 = 0

  public var organizationID: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Wendycloud_V1_CreateUserEnrollmentTokenResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Opaque signed token the user will use
  public var enrollmentToken: String = String()

  /// Token id for auditing
  public var jti: String = String()

  public var expiresAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _expiresAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_expiresAt = newValue}
  }
  /// Returns true if `expiresAt` has been explicitly set.
  public var hasExpiresAt: Bool {return self._expiresAt != nil}
  /// Clears the value of `expiresAt`. Subsequent reads from it will return its default value.
  public mutating func clearExpiresAt() {self._expiresAt = nil}

  /// User this token is for
  public var userID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _expiresAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Structured error information for certificate operations
public struct Wendycloud_V1_CertificateError: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Machine-readable error code
  public var code: Wendycloud_V1_CertificateErrorCode = .certificateErrorUnspecified

  /// Human-readable error message
  public var message: String = String()

  /// Optional additional context (e.g., CSR validation details)
  public var details: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "wendycloud.v1"

extension Wendycloud_V1_CertificateStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0CERTIFICATE_STATUS_UNSPECIFIED\0\u{1}CERTIFICATE_STATUS_ACTIVE\0\u{1}CERTIFICATE_STATUS_REVOKED\0\u{1}CERTIFICATE_STATUS_EXPIRED\0")
}

extension Wendycloud_V1_CertificateErrorCode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0CERTIFICATE_ERROR_UNSPECIFIED\0\u{1}CERTIFICATE_ERROR_INVALID_CSR\0\u{1}CERTIFICATE_ERROR_INVALID_ENROLLMENT_TOKEN\0\u{1}CERTIFICATE_ERROR_UNAUTHORIZED\0\u{1}CERTIFICATE_ERROR_ORGANIZATION_NOT_FOUND\0\u{1}CERTIFICATE_ERROR_ASSET_NOT_FOUND\0\u{1}CERTIFICATE_ERROR_CA_SERVICE_UNAVAILABLE\0\u{1}CERTIFICATE_ERROR_QUOTA_EXCEEDED\0\u{1}CERTIFICATE_ERROR_CERTIFICATE_REVOKED\0\u{1}CERTIFICATE_ERROR_CERTIFICATE_EXPIRED\0\u{1}CERTIFICATE_ERROR_INVALID_COMMON_NAME\0\u{1}CERTIFICATE_ERROR_INTERNAL\0")
}

extension Wendycloud_V1_GetCertificateMetadataRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetCertificateMetadataRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Wendycloud_V1_GetCertificateMetadataRequest, rhs: Wendycloud_V1_GetCertificateMetadataRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Wendycloud_V1_GetCertificateMetadataResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetCertificateMetadataResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}organization_id\0\u{3}asset_id\0\u{3}user_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.organizationID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._assetID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.organizationID != 0 {
      try visitor.visitSingularInt32Field(value: self.organizationID, fieldNumber: 1)
    }
    try { if let v = self._assetID {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._userID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Wendycloud_V1_GetCertificateMetadataResponse, rhs: Wendycloud_V1_GetCertificateMetadataResponse) -> Bool {
    if lhs.organizationID != rhs.organizationID {return false}
    if lhs._assetID != rhs._assetID {return false}
    if lhs._userID != rhs._userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Wendycloud_V1_Certificate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Certificate"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{3}organization_id\0\u{3}asset_id\0\u{3}serial_number\0\u{3}pem_certificate\0\u{3}pem_certificate_chain\0\u{3}not_before\0\u{3}not_after\0\u{1}status\0\u{3}revoked_at\0\u{3}revocation_reason\0\u{3}created_at\0\u{3}updated_at\0\u{3}user_id\0")

  fileprivate class _StorageClass {
    var _id: Int32 = 0
    var _organizationID: Int32 = 0
    var _assetID: Int32? = nil
    var _userID: String? = nil
    var _serialNumber: String = String()
    var _pemCertificate: String = String()
    var _pemCertificateChain: String = String()
    var _notBefore: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _notAfter: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _status: Wendycloud_V1_CertificateStatus = .unspecified
    var _revokedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _revocationReason: String = String()
    var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _organizationID = source._organizationID
      _assetID = source._assetID
      _userID = source._userID
      _serialNumber = source._serialNumber
      _pemCertificate = source._pemCertificate
      _pemCertificateChain = source._pemCertificateChain
      _notBefore = source._notBefore
      _notAfter = source._notAfter
      _status = source._status
      _revokedAt = source._revokedAt
      _revocationReason = source._revocationReason
      _createdAt = source._createdAt
      _updatedAt = source._updatedAt
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt32Field(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularInt32Field(value: &_storage._organizationID) }()
        case 3: try { try decoder.decodeSingularInt32Field(value: &_storage._assetID) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._serialNumber) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._pemCertificate) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._pemCertificateChain) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._notBefore) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._notAfter) }()
        case 9: try { try decoder.decodeSingularEnumField(value: &_storage._status) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._revokedAt) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._revocationReason) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._createdAt) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._updatedAt) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._userID) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._id != 0 {
        try visitor.visitSingularInt32Field(value: _storage._id, fieldNumber: 1)
      }
      if _storage._organizationID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._organizationID, fieldNumber: 2)
      }
      try { if let v = _storage._assetID {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
      } }()
      if !_storage._serialNumber.isEmpty {
        try visitor.visitSingularStringField(value: _storage._serialNumber, fieldNumber: 4)
      }
      if !_storage._pemCertificate.isEmpty {
        try visitor.visitSingularStringField(value: _storage._pemCertificate, fieldNumber: 5)
      }
      if !_storage._pemCertificateChain.isEmpty {
        try visitor.visitSingularStringField(value: _storage._pemCertificateChain, fieldNumber: 6)
      }
      try { if let v = _storage._notBefore {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._notAfter {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if _storage._status != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._status, fieldNumber: 9)
      }
      try { if let v = _storage._revokedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      if !_storage._revocationReason.isEmpty {
        try visitor.visitSingularStringField(value: _storage._revocationReason, fieldNumber: 11)
      }
      try { if let v = _storage._createdAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._updatedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._userID {
        try visitor.visitSingularStringField(value: v, fieldNumber: 14)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Wendycloud_V1_Certificate, rhs: Wendycloud_V1_Certificate) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._organizationID != rhs_storage._organizationID {return false}
        if _storage._assetID != rhs_storage._assetID {return false}
        if _storage._userID != rhs_storage._userID {return false}
        if _storage._serialNumber != rhs_storage._serialNumber {return false}
        if _storage._pemCertificate != rhs_storage._pemCertificate {return false}
        if _storage._pemCertificateChain != rhs_storage._pemCertificateChain {return false}
        if _storage._notBefore != rhs_storage._notBefore {return false}
        if _storage._notAfter != rhs_storage._notAfter {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._revokedAt != rhs_storage._revokedAt {return false}
        if _storage._revocationReason != rhs_storage._revocationReason {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._updatedAt != rhs_storage._updatedAt {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Wendycloud_V1_IssueCertificateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IssueCertificateRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{4}\u{3}pem_csr\0\u{4}\u{2}enrollment_token\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3: try { try decoder.decodeSingularStringField(value: &self.pemCsr) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.enrollmentToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pemCsr.isEmpty {
      try visitor.visitSingularStringField(value: self.pemCsr, fieldNumber: 3)
    }
    if !self.enrollmentToken.isEmpty {
      try visitor.visitSingularStringField(value: self.enrollmentToken, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Wendycloud_V1_IssueCertificateRequest, rhs: Wendycloud_V1_IssueCertificateRequest) -> Bool {
    if lhs.pemCsr != rhs.pemCsr {return false}
    if lhs.enrollmentToken != rhs.enrollmentToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Wendycloud_V1_IssueCertificateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IssueCertificateResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}certificate\0\u{1}error\0\u{1}warnings\0\u{3}organization_id\0\u{3}asset_id\0\u{3}user_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._certificate) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.warnings) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.organizationID) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self._assetID) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._certificate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.warnings.isEmpty {
      try visitor.visitRepeatedStringField(value: self.warnings, fieldNumber: 3)
    }
    if self.organizationID != 0 {
      try visitor.visitSingularInt32Field(value: self.organizationID, fieldNumber: 4)
    }
    try { if let v = self._assetID {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._userID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Wendycloud_V1_IssueCertificateResponse, rhs: Wendycloud_V1_IssueCertificateResponse) -> Bool {
    if lhs._certificate != rhs._certificate {return false}
    if lhs._error != rhs._error {return false}
    if lhs.warnings != rhs.warnings {return false}
    if lhs.organizationID != rhs.organizationID {return false}
    if lhs._assetID != rhs._assetID {return false}
    if lhs._userID != rhs._userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Wendycloud_V1_RefreshCertificateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RefreshCertificateRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{4}\u{3}pem_csr\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3: try { try decoder.decodeSingularStringField(value: &self.pemCsr) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pemCsr.isEmpty {
      try visitor.visitSingularStringField(value: self.pemCsr, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Wendycloud_V1_RefreshCertificateRequest, rhs: Wendycloud_V1_RefreshCertificateRequest) -> Bool {
    if lhs.pemCsr != rhs.pemCsr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Wendycloud_V1_RefreshCertificateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RefreshCertificateResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}certificate\0\u{1}error\0\u{1}warnings\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._certificate) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.warnings) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._certificate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.warnings.isEmpty {
      try visitor.visitRepeatedStringField(value: self.warnings, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Wendycloud_V1_RefreshCertificateResponse, rhs: Wendycloud_V1_RefreshCertificateResponse) -> Bool {
    if lhs._certificate != rhs._certificate {return false}
    if lhs._error != rhs._error {return false}
    if lhs.warnings != rhs.warnings {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Wendycloud_V1_RevokeCertificateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RevokeCertificateRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}certificate_id\0\u{1}reason\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.certificateID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.certificateID != 0 {
      try visitor.visitSingularInt32Field(value: self.certificateID, fieldNumber: 1)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Wendycloud_V1_RevokeCertificateRequest, rhs: Wendycloud_V1_RevokeCertificateRequest) -> Bool {
    if lhs.certificateID != rhs.certificateID {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Wendycloud_V1_RevokeCertificateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RevokeCertificateResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Wendycloud_V1_RevokeCertificateResponse, rhs: Wendycloud_V1_RevokeCertificateResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Wendycloud_V1_GetCertificateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetCertificateRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}certificate_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.certificateID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.certificateID != 0 {
      try visitor.visitSingularInt32Field(value: self.certificateID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Wendycloud_V1_GetCertificateRequest, rhs: Wendycloud_V1_GetCertificateRequest) -> Bool {
    if lhs.certificateID != rhs.certificateID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Wendycloud_V1_ListCertificatesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListCertificatesRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}asset_id\0\u{1}offset\0\u{1}limit\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.assetID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._offset) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._limit) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.assetID != 0 {
      try visitor.visitSingularInt32Field(value: self.assetID, fieldNumber: 1)
    }
    try { if let v = self._offset {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._limit {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Wendycloud_V1_ListCertificatesRequest, rhs: Wendycloud_V1_ListCertificatesRequest) -> Bool {
    if lhs.assetID != rhs.assetID {return false}
    if lhs._offset != rhs._offset {return false}
    if lhs._limit != rhs._limit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Wendycloud_V1_ListCertificatesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListCertificatesResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}certificate\0\u{1}total\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._certificate) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.total) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._certificate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.total != 0 {
      try visitor.visitSingularInt32Field(value: self.total, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Wendycloud_V1_ListCertificatesResponse, rhs: Wendycloud_V1_ListCertificatesResponse) -> Bool {
    if lhs._certificate != rhs._certificate {return false}
    if lhs.total != rhs.total {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Wendycloud_V1_GetCaBundleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetCaBundleRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Wendycloud_V1_GetCaBundleRequest, rhs: Wendycloud_V1_GetCaBundleRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Wendycloud_V1_GetCaBundleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetCaBundleResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}pem_bundle\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pemBundle) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pemBundle.isEmpty {
      try visitor.visitSingularStringField(value: self.pemBundle, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Wendycloud_V1_GetCaBundleResponse, rhs: Wendycloud_V1_GetCaBundleResponse) -> Bool {
    if lhs.pemBundle != rhs.pemBundle {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Wendycloud_V1_CreateAssetEnrollmentTokenRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateAssetEnrollmentTokenRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}organization_id\0\u{1}name\0\u{3}ttl_seconds\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.organizationID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.ttlSeconds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.organizationID != 0 {
      try visitor.visitSingularInt32Field(value: self.organizationID, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if self.ttlSeconds != 0 {
      try visitor.visitSingularInt32Field(value: self.ttlSeconds, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Wendycloud_V1_CreateAssetEnrollmentTokenRequest, rhs: Wendycloud_V1_CreateAssetEnrollmentTokenRequest) -> Bool {
    if lhs.organizationID != rhs.organizationID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.ttlSeconds != rhs.ttlSeconds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Wendycloud_V1_CreateAssetEnrollmentTokenResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateAssetEnrollmentTokenResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}enrollment_token\0\u{1}jti\0\u{3}expires_at\0\u{3}organization_id\0\u{3}asset_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.enrollmentToken) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.jti) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._expiresAt) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.organizationID) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.assetID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.enrollmentToken.isEmpty {
      try visitor.visitSingularStringField(value: self.enrollmentToken, fieldNumber: 1)
    }
    if !self.jti.isEmpty {
      try visitor.visitSingularStringField(value: self.jti, fieldNumber: 2)
    }
    try { if let v = self._expiresAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.organizationID != 0 {
      try visitor.visitSingularInt32Field(value: self.organizationID, fieldNumber: 4)
    }
    if self.assetID != 0 {
      try visitor.visitSingularInt32Field(value: self.assetID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Wendycloud_V1_CreateAssetEnrollmentTokenResponse, rhs: Wendycloud_V1_CreateAssetEnrollmentTokenResponse) -> Bool {
    if lhs.enrollmentToken != rhs.enrollmentToken {return false}
    if lhs.jti != rhs.jti {return false}
    if lhs._expiresAt != rhs._expiresAt {return false}
    if lhs.organizationID != rhs.organizationID {return false}
    if lhs.assetID != rhs.assetID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Wendycloud_V1_CreateUserEnrollmentTokenRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateUserEnrollmentTokenRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{4}\u{2}ttl_seconds\0\u{3}organization_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.ttlSeconds) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.organizationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.ttlSeconds != 0 {
      try visitor.visitSingularInt32Field(value: self.ttlSeconds, fieldNumber: 2)
    }
    if self.organizationID != 0 {
      try visitor.visitSingularInt32Field(value: self.organizationID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Wendycloud_V1_CreateUserEnrollmentTokenRequest, rhs: Wendycloud_V1_CreateUserEnrollmentTokenRequest) -> Bool {
    if lhs.ttlSeconds != rhs.ttlSeconds {return false}
    if lhs.organizationID != rhs.organizationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Wendycloud_V1_CreateUserEnrollmentTokenResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateUserEnrollmentTokenResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}enrollment_token\0\u{1}jti\0\u{3}expires_at\0\u{4}\u{2}user_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.enrollmentToken) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.jti) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._expiresAt) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.enrollmentToken.isEmpty {
      try visitor.visitSingularStringField(value: self.enrollmentToken, fieldNumber: 1)
    }
    if !self.jti.isEmpty {
      try visitor.visitSingularStringField(value: self.jti, fieldNumber: 2)
    }
    try { if let v = self._expiresAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Wendycloud_V1_CreateUserEnrollmentTokenResponse, rhs: Wendycloud_V1_CreateUserEnrollmentTokenResponse) -> Bool {
    if lhs.enrollmentToken != rhs.enrollmentToken {return false}
    if lhs.jti != rhs.jti {return false}
    if lhs._expiresAt != rhs._expiresAt {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Wendycloud_V1_CertificateError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CertificateError"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}details\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.details) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .certificateErrorUnspecified {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.details.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.details, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Wendycloud_V1_CertificateError, rhs: Wendycloud_V1_CertificateError) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.details != rhs.details {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
