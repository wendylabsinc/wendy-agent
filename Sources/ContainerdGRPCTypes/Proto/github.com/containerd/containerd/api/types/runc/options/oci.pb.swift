// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: github.com/containerd/containerd/api/types/runc/options/oci.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Containerd_Runc_V1_Options: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// disable pivot root when creating a container
  public var noPivotRoot: Bool = false

  /// create a new keyring for the container
  public var noNewKeyring: Bool = false

  /// place the shim in a cgroup
  public var shimCgroup: String = String()

  /// set the I/O's pipes uid
  public var ioUid: UInt32 = 0

  /// set the I/O's pipes gid
  public var ioGid: UInt32 = 0

  /// binary name of the runc binary
  public var binaryName: String = String()

  /// runc root directory
  public var root: String = String()

  /// enable systemd cgroups
  public var systemdCgroup: Bool = false

  /// criu image path
  public var criuImagePath: String = String()

  /// criu work path
  public var criuWorkPath: String = String()

  /// task api address, can be a unix domain socket, or vsock address.
  /// it is in the form of ttrpc+unix://path/to/uds or grpc+vsock://<vsock cid>:<port>.
  public var taskApiAddress: String = String()

  /// task api version, currently supported value is 2 and 3.
  public var taskApiVersion: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Containerd_Runc_V1_CheckpointOptions: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// exit the container after a checkpoint
  public var exit: Bool = false

  /// checkpoint open tcp connections
  public var openTcp: Bool = false

  /// checkpoint external unix sockets
  public var externalUnixSockets: Bool = false

  /// checkpoint terminals (ptys)
  public var terminal: Bool = false

  /// allow checkpointing of file locks
  public var fileLocks: Bool = false

  /// restore provided namespaces as empty namespaces
  public var emptyNamespaces: [String] = []

  /// set the cgroups mode, soft, full, strict
  public var cgroupsMode: String = String()

  /// checkpoint image path
  public var imagePath: String = String()

  /// checkpoint work path
  public var workPath: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Containerd_Runc_V1_ProcessDetails: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// exec process id if the process is managed by a shim
  public var execID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "containerd.runc.v1"

extension Containerd_Runc_V1_Options: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Options"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}no_pivot_root\0\u{3}no_new_keyring\0\u{3}shim_cgroup\0\u{3}io_uid\0\u{3}io_gid\0\u{3}binary_name\0\u{1}root\0\u{4}\u{2}systemd_cgroup\0\u{3}criu_image_path\0\u{3}criu_work_path\0\u{3}task_api_address\0\u{3}task_api_version\0\u{c}\u{8}\u{1}")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.noPivotRoot) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.noNewKeyring) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.shimCgroup) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.ioUid) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.ioGid) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.binaryName) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.root) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.systemdCgroup) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.criuImagePath) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.criuWorkPath) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.taskApiAddress) }()
      case 13: try { try decoder.decodeSingularUInt32Field(value: &self.taskApiVersion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.noPivotRoot != false {
      try visitor.visitSingularBoolField(value: self.noPivotRoot, fieldNumber: 1)
    }
    if self.noNewKeyring != false {
      try visitor.visitSingularBoolField(value: self.noNewKeyring, fieldNumber: 2)
    }
    if !self.shimCgroup.isEmpty {
      try visitor.visitSingularStringField(value: self.shimCgroup, fieldNumber: 3)
    }
    if self.ioUid != 0 {
      try visitor.visitSingularUInt32Field(value: self.ioUid, fieldNumber: 4)
    }
    if self.ioGid != 0 {
      try visitor.visitSingularUInt32Field(value: self.ioGid, fieldNumber: 5)
    }
    if !self.binaryName.isEmpty {
      try visitor.visitSingularStringField(value: self.binaryName, fieldNumber: 6)
    }
    if !self.root.isEmpty {
      try visitor.visitSingularStringField(value: self.root, fieldNumber: 7)
    }
    if self.systemdCgroup != false {
      try visitor.visitSingularBoolField(value: self.systemdCgroup, fieldNumber: 9)
    }
    if !self.criuImagePath.isEmpty {
      try visitor.visitSingularStringField(value: self.criuImagePath, fieldNumber: 10)
    }
    if !self.criuWorkPath.isEmpty {
      try visitor.visitSingularStringField(value: self.criuWorkPath, fieldNumber: 11)
    }
    if !self.taskApiAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.taskApiAddress, fieldNumber: 12)
    }
    if self.taskApiVersion != 0 {
      try visitor.visitSingularUInt32Field(value: self.taskApiVersion, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Containerd_Runc_V1_Options, rhs: Containerd_Runc_V1_Options) -> Bool {
    if lhs.noPivotRoot != rhs.noPivotRoot {return false}
    if lhs.noNewKeyring != rhs.noNewKeyring {return false}
    if lhs.shimCgroup != rhs.shimCgroup {return false}
    if lhs.ioUid != rhs.ioUid {return false}
    if lhs.ioGid != rhs.ioGid {return false}
    if lhs.binaryName != rhs.binaryName {return false}
    if lhs.root != rhs.root {return false}
    if lhs.systemdCgroup != rhs.systemdCgroup {return false}
    if lhs.criuImagePath != rhs.criuImagePath {return false}
    if lhs.criuWorkPath != rhs.criuWorkPath {return false}
    if lhs.taskApiAddress != rhs.taskApiAddress {return false}
    if lhs.taskApiVersion != rhs.taskApiVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Containerd_Runc_V1_CheckpointOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CheckpointOptions"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}exit\0\u{3}open_tcp\0\u{3}external_unix_sockets\0\u{1}terminal\0\u{3}file_locks\0\u{3}empty_namespaces\0\u{3}cgroups_mode\0\u{3}image_path\0\u{3}work_path\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.exit) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.openTcp) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.externalUnixSockets) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.terminal) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.fileLocks) }()
      case 6: try { try decoder.decodeRepeatedStringField(value: &self.emptyNamespaces) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.cgroupsMode) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.imagePath) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.workPath) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.exit != false {
      try visitor.visitSingularBoolField(value: self.exit, fieldNumber: 1)
    }
    if self.openTcp != false {
      try visitor.visitSingularBoolField(value: self.openTcp, fieldNumber: 2)
    }
    if self.externalUnixSockets != false {
      try visitor.visitSingularBoolField(value: self.externalUnixSockets, fieldNumber: 3)
    }
    if self.terminal != false {
      try visitor.visitSingularBoolField(value: self.terminal, fieldNumber: 4)
    }
    if self.fileLocks != false {
      try visitor.visitSingularBoolField(value: self.fileLocks, fieldNumber: 5)
    }
    if !self.emptyNamespaces.isEmpty {
      try visitor.visitRepeatedStringField(value: self.emptyNamespaces, fieldNumber: 6)
    }
    if !self.cgroupsMode.isEmpty {
      try visitor.visitSingularStringField(value: self.cgroupsMode, fieldNumber: 7)
    }
    if !self.imagePath.isEmpty {
      try visitor.visitSingularStringField(value: self.imagePath, fieldNumber: 8)
    }
    if !self.workPath.isEmpty {
      try visitor.visitSingularStringField(value: self.workPath, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Containerd_Runc_V1_CheckpointOptions, rhs: Containerd_Runc_V1_CheckpointOptions) -> Bool {
    if lhs.exit != rhs.exit {return false}
    if lhs.openTcp != rhs.openTcp {return false}
    if lhs.externalUnixSockets != rhs.externalUnixSockets {return false}
    if lhs.terminal != rhs.terminal {return false}
    if lhs.fileLocks != rhs.fileLocks {return false}
    if lhs.emptyNamespaces != rhs.emptyNamespaces {return false}
    if lhs.cgroupsMode != rhs.cgroupsMode {return false}
    if lhs.imagePath != rhs.imagePath {return false}
    if lhs.workPath != rhs.workPath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Containerd_Runc_V1_ProcessDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ProcessDetails"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}exec_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.execID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.execID.isEmpty {
      try visitor.visitSingularStringField(value: self.execID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Containerd_Runc_V1_ProcessDetails, rhs: Containerd_Runc_V1_ProcessDetails) -> Bool {
    if lhs.execID != rhs.execID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
